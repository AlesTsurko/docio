Eerie
Markdown

//metadoc Docio category API
//metadoc Docio description Main interface for Docio. 
Docio := Object clone do(
    //doc Docio prototypes A map of documented prototypes.
    prototypes   := Map clone
    modules      := Map clone
    categories   := Map clone
    //doc Docio packagePath Path of the package directory.
    packagePath  ::= nil
    outputPath   := method(packagePath .. "/docs")
    //doc Docio packageInfo Returns package.json as an instance of Map.
    packageInfo  := nil
    //doc Docio packageName Returns the name of the package as it's specified in the package.json.
    packageName  := nil
    templatePath ::= nil
    
    getDocioPackage := method(
        return Eerie activeEnv packageNamed("Docio")
    )

    //doc Docio generateDocs Generates documentation for the package at `packagePath`.
    generateDocs := method(
        parsePackageJSON
        copyTemplate(Directory with(templatePath))
        extractDocs
        parseDocs
        generateCategories
        writeDocsToJson
        generateSite
    )

    parsePackageJSON := method(
        packageJson := getDestinationPackageJSON()
        packageInfo = Yajl parseJson(packageJson contents)
        packageName = packageInfo at("name")

        if(packageName == nil,
          Exception raise("The \"name\" field of the package.json is nil.")
        )
    )

    getDestinationPackageJSON := method(
        packageJson := File with(packagePath .. "/package.json")
        if(packageJson exists,
            packageJson open
            return packageJson
            ,
            Exception raise("Error: package.json didn't found")
        )
    )

    copyTemplate := method(templateDir,
        // switch to template directory
        currentDirectoryPath := Directory currentWorkingDirectory
        Directory setCurrentWorkingDirectory(templateDir path)
        // copy files
        Directory walk(item, 
            if(item type == "Directory",
                createDirectoryInDestination(item),
                copyFileToDestination(item)
            )
        )
        // switch back to current directory
        Directory setCurrentWorkingDirectory(currentDirectoryPath)
    )

    createDirectoryInDestination := method(directory,
        directoryPath := outputPath .. "/" .. directory path afterSeq("./")
        Directory with(directoryPath) createIfAbsent
    )

    copyFileToDestination := method(file,
        if(file path pathExtension != "DS_Store" and file name != "main_template.html" and file name != "prototype_template.html" and file path pathExtension != "io",
            destinationPath := outputPath .. "/" .. file path afterSeq("./")
            file copyToPath(destinationPath)
        )
    )

    extractDocs := method(
        docsExtractor := DocsExtractor clone
        docsExtractor setPath(packagePath)
        docsExtractor extract
    )

    //doc Docio parseDocs Parses `docs.txt` generated by DocsExtractor and fills up the `prototypes` map.
    parseDocs := method(
        docsTxt := getDocsTxt()
        docsTxt contents split("------\n") foreach(entry, parseDocEntry(entry))
    )

    getDocsTxt := method(
        docsTxt := File with(Path with(packagePath, "/docs/docs.txt"))
        docsTxt exists ifFalse(
            Exception raise("#{packagePath}/docs/docs.txt not found" interpolate)
        )

        return docsTxt
    )

    parseDocEntry := method(docEntry,
        header := docEntry beforeSeq("\n") afterSeq(" ") 
        if(header, parseDocHeader(header, docEntry))
    )

    parseDocHeader := method(header, docEntry,
        headerCopy := header asMutable strip asSymbol
        protoName := headerCopy beforeSeq(" ") ?asMutable ?strip ?asSymbol
        prototypes atIfAbsentPut(protoName, Map clone atPut("slots", Map clone))
        if(protoName == nil, writeln("ERROR: " .. headerCopy))
        parseDocSlot(headerCopy, docEntry, protoName)
    )

    parseDocSlot := method(header, docEntry, protoName,
        slotName := header afterSeq(" ") ?asMutable ?strip ?asSymbol
        if(slotName == nil, writeln("ERROR: " .. header))
        description := docEntry afterSeq("\n") markdownToHTML

        isSlot := docEntry beginsWithSeq("doc")
        if(isSlot, 
            prototypes at(protoName) at("slots") atPut(slotName, description)
            ,
            prototypes at(protoName) atPut(slotName, description)
        )
    )

    generateCategories := method(
        //TODO: refactor
        firstProto := nil
        firstProtoName := prototypes keys sort detect(k, prototypes at(k) at("category"))

        catNameMap := Map clone
        prototypes values select(at("category")) foreach(m, 
            count := catNameMap at(m at("category")) 
            if(count == nil, count = 0)
            catNameMap atPut(m at("category"), count + 1)
        )

        maxCount := 0
        catName := nil
        catNameMap foreach(name, count,
            if(count > maxCount, catName = name; maxCount = count)
        )

        if(catName == nil, catName = "Misc")
        categories atIfAbsentPut(catName asMutable strip, prototypes)
    )

    writeDocsToJson := method(
        if(prototypes size < 1, return)
        docsJson := File with(outputPath .. "/data.js") create
        docsJson open
        docsJson setContents("data = JSON.stringify(" .. prototypes asJson .. ");")
        docsJson close
    )

    generateSite := method(
        PageGenerator init
        PageGenerator generateSite
    )

    printDocFor := method(query,
        queryList := getListForQuery(query)
        addonName := queryList at(0)

        if(AddonLoader hasAddonNamed(addonName),
            prepareDocsForPackageNamed(addonName)
            result := getDocStringForQueryList(queryList)
            printDocsString(result)
            ,
            Exception raise("Can't find a package with name " .. addonName)
        )
    )

    getListForQuery := method(query,
        queryList := query asMutable splitNoEmpties
        if(queryList isEmpty, 
            Exception raise("Can't process query: " .. query)
        )
        return queryList
    )

    prepareDocsForPackageNamed := method(name,
        addon := AddonLoader addonFor(name)
        setPackagePath(addon addonPath)
        exception := try(
            getDocsTxt
            parseDocs
        )
        exception catch (
            setTemplatePath(getDocioPackage path .. "/template")
            generateDocs
            parseDocs
        )
    )

    getDocStringForQueryList := method(queryList,
        docString := ""
        (queryList size == 1) ifTrue(
            docString := prototypes at(queryList at(0)) ?at("description")
        )
        (queryList size == 2) ifTrue(
            docString := prototypes at(queryList at(0)) ?at("slots") ?at(queryList at(1))
        )
        (queryList size == 3) ifTrue(
            docString := prototypes at(queryList at(1)) ?at("slots") ?at(queryList at(2))
        )
        (queryList size > 3) ifTrue(
            Exception raise("Wrong query: " queryList join(" "))
        )
        return docString
    )

    printDocsString := method(docString,
        if(docString not or docString isEmpty, 
            "Documentation didn't found." println
            ,
            docString println
        )
    )
)

Docio clone := Docio do(
    doRelativeFile("Docio/CLI.io")
    doRelativeFile("Docio/PageGenerator.io")
    doRelativeFile("Docio/DocsExtractor.io")
)
